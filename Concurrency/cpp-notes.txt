concurrency - running threads in sequence; if one thread waits we move to execute another operation 
concurrency != parallelism

- concurrency: order matters and tasks must wait
- parallelism: everything happens at once 

both enable better computational performance 
each core has a number of transistors - do the operations 
as clock speed (rate of operations a single core can execute) increases more heat generated 

one way to achieve concurrency is by using threads
thread = lightweight processes

best to use threads in heavy computation and seperating work

in c++ there is the standard thread library

synchornization - creating order between when threads are running 
use .join() method so we wait for a threads completion

ensure you are using correct version of C++ >= 11 can pass -std=c++17 flag to g++ compiler

can create threads with lambda functions as well

threads can also share data --> but need to be careful

data race
possible problem: reading and writing of shared_values by threads

std::mutex = mutual exclusive
only a single thread can read/write from a shared value at any time

Better then mutex
std::atomic = indivisible operation
can use atomic data type to template shared values so they reading/writing is locked to single thread at any time
certain operations overloaded including x++, x+=1
meaning some things wont still work even if data types wrapped with atomic e.g x = x + 1